/*
Copyright Â© AngDev.tk
All Rights Reserved
*/

/* ------------ U T I L S ------------ */
const Util = require('../util.js');
const mainURL = 'https://angdev.angelobg2007.repl.co/';
const apiURL = `${mainURL}api/images/`;
const assets = '../assets/';

/* ------------ P A C K A G E S ------------ */
const Canvas = require('canvas');
const GIFEncoder = require("gifencoder");
const path = require('path');
const fetch = require('node-fetch');
const jimp = require('jimp');

module.exports = {

  /* ------------ G I F ------------ */

  petpet: async function petpet(url, { frames } = {}) {

    if (!url) {
      throw new Error('No image given for #PetPet');
    }

    if (!frames) {
      frames = 3;
    }

    if (isNaN(frames)) {
      throw new Error('Frames for #PetPet must be a number');
    }

    let newFrames = frames.toString().substring(0, 1);

    if (!newFrames) {
      throw new Error('Invalid frames given for #PetPet')
    }

    if (isNaN(newFrames)) {
      throw new Error('Frames for #PetPet must be a number')
    }

    frames = `${newFrames}0`;

    const size = 2000;

    try {

      const img = await Canvas.loadImage(url).catch(e => {
        throw new Error('Falied to load image for #PetPet')
      });

      const GIF = new GIFEncoder(size, size)
      GIF.start();
      GIF.setRepeat(0);
      GIF.setDelay(parseInt(frames));
      GIF.setTransparent('#000000');

      const canvas = Canvas.createCanvas(size, size);
      const ctx = canvas.getContext('2d');

      for (let i = 0; i < 5; i++) {

        const j = i < 5 / 2 ? i : 5 - i,
          width = 0.8 + j * 0.03,
          height = 0.8 - j * 0.05,
          offsetX = (1 - width) * 0.5 + 0.1,
          offsetY = (1 - height) - 0.08;

        let hand = await Canvas.loadImage(path.join(__dirname + '../../assets', 'images', `hand${i + 1}.png`))

        ctx.drawImage(img, size * offsetX, size * offsetY, size * width, size * height);
        ctx.drawImage(hand, 0, 0, size, size);
        GIF.addFrame(ctx);
        i++;
        ctx.clearRect(0, 0, size, size);
      }
      GIF.finish();

      return GIF.out.getData();

    } catch (e) {
      throw new Error(e + '.')
    }
  },

  blink: async function (...images) {

    if (!urls) {
      throw new Error('No image url given for #Blink')
    }

    if (urls < 2) {
      throw new Error('Minumum 2 images for #Blink')
    }

    let size = 2000;

    try {

      const GIF = new GIFEncoder(size, size);
      GIF.start();
      GIF.setRepeat(0);
      GIF.setDelay(1000);
      GIF.setTransparent();

      const canvas = Canvas.createCanvas(size, size);

      for (const image of images) {

        const base = await Canvas.loadImage(image);
        const ctx = canvas.getContext(`2d`);
        ctx.clearRect(0, 0, size, size);
        ctx.drawImage(base, 0, 0, size, size);
        GIF.addFrame(ctx);
      }

      GIF.finish();

      return GIF.out.getData();

    } catch (e) {
      throw new Error(e + '.');
    }

  },

  trigger: async function (url) {

    if (!url) {
      throw new Error('No image given for #Trigger')
    }


    try {

      const base = await Canvas.loadImage(path.join(__dirname + '../../assets', 'images', `trigger.png`))
      const img = await Canvas.loadImage(url);

      const GIF = new GIFEncoder(256, 256);

      GIF.start();
      GIF.setRepeat(0);
      GIF.setDelay(15);

      const canvas = Canvas.createCanvas(256, 256);
      const ctx = canvas.getContext('2d');

      const BR = 30;
      const LR = 20;

      let i = 0;

      while (i < 9) {

        ctx.clearRect(0, 0, 256, 256);

        ctx.drawImage(img, Math.floor(Math.random() * BR) - BR, Math.floor(Math.random() * BR) - BR, 256 + BR, 310 - 54 + BR);

        ctx.fillStyle = "rgba(255, 0, 0, 0.18)";
        ctx.fillRect(0, 0, 256, 310);

        ctx.drawImage(base, Math.floor(Math.random() * LR) - LR, 270 - 54 + Math.floor(Math.random() * LR) - LR, 256 + LR, 54 + LR);

        GIF.addFrame(ctx);
        i++;
      }

      GIF.finish();

      return GIF.out.getData();
    } catch (e) {
      throw new Error(e + '.');
    }

  },

  /* ------------ PNG ------------ */

  ad: async function (url) {

    if (!url) {
      throw new Error('No image given for #Ad')
    }

    try {

      const img = await Canvas.loadImage(url);

      const canvas = Canvas.createCanvas(550, 474);
      const ctx = canvas.getContext(`2d`);
      const background = await Canvas.loadImage(path.join(__dirname + '../../assets', 'images', `ad.png`));
      ctx.drawImage(img, 150, 75, 230, 230);
      ctx.drawImage(background, 0, 0, 550, 474);

      return canvas.toBuffer();

    } catch (e) {
      throw new Error(e + '.');
    }

  },

  circle: async function (url) {

    if (!url) {
      throw new Error('No image given for #Trigger')
    }

    try {

      let img = await jimp.read(url);
      img.circle();

      let raw;
      img.getBuffer(`image/png`, (err, buffer) => {

        if (err) {
          throw new Error(err + '.');
        }

        raw = buffer;

      });

      return raw;

    } catch (e) {
      throw new Error(e + '.');
    }

  }

}